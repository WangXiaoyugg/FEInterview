<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>面向对象</title></head><body><script>    //类的声明    function Animal(){        this.name = 'name'    }    //es6 class声明    class Person{        constructor(){            this.name = name;        }    }    //实例化类的对象    console.log( new Animal(),new Person());    //类的继承    /*     * 构造函数实现继承,不能继承父类.prototype的方法     */    function Parent1(){        this.name = 'parent1';    }    Parent1.prototype.say = function () {};    function Child1(){        Parent1.call(this); //call的方式,改变this的指向        this.type = 'child1';    }    console.log(new Child1());    /*     *原型链实现继承,     * 继承都是一个父类的原型，     * 一个实例改变会修改原型     * 另一个实例也会改变     */    function Parent2(){        this.name = 'parent2';        this.play = [1,2,3];    }    function Child2() {        this.type = 'child2'    }    Child2.prototype = new Parent2();    console.log(new Child2());    var s1 = new Child2();    var s2 = new Child2();    console.log(s1.play,s2.play);    s1.play.push(4);    /*     * 组合方式继承,没有构造函数和原型链的缺点     * 缺点父类执行了两次     */    function Parent3(){        this.name = 'parent3';        this.play = [1,2,3];    }    function Child3() {        Parent3.call(this);        this.type = 'child3'    }    Child3.prototype = new Parent3();    var s3 = new Child3();    var s4 = new Child3();    s3.play.push(5);    console.log(s3.play,s4.play);    /*     *组合继承的优化1     * 无法区分是子类还是父类实例化     * 子类实例化没有自身的constructor;     */    function Parent4(){        this.name = 'parent4';        this.play = [1,2,3];    }    function Child4() {        Parent4.call(this);        this.type = 'child4'    }    Child3.prototype = Parent4.prototype;    var s5 = new Child4();    var s6 = new Child4();    s5.play.push(5);    console.log(s5,s6);    console.log(s5 instanceof Child4,s6 instanceof Parent4);    console.log(s5.constructor);    /*     *组合继承的优化2 完美     */    function Parent5(){        this.name = 'parent5';        this.play = [1,2,3];    }    function Child5() {        Parent4.call(this);        this.type = 'child5'    }    //Object.create()做中介    Child5.prototype = Object.create(Parent5.prototype);    Child5.prototype.constructor = Child5;    var s7 = new Child5();    console.log(s7 instanceof Child5,s7 instanceof Parent5);    console.log(s7.constructor);    //es6继承    class student extends Person {        constructor(name,age) {            super(name); // 调用父类的constructor(x, y)            this.age = 18 ;        }        toString() {            return this.age + ' ' + super.toString(); // 调用父类的toString()        }    }</script></body></html>